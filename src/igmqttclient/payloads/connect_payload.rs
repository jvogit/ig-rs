// Autogenerated by Thrift Compiler (0.18.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

//
// ConnectPayload
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConnectPayload {
  pub client_identifier: Option<String>,
  pub client_info: Option<Box<ClientInfo>>,
  pub password: Option<String>,
  pub app_specific_info: Option<BTreeMap<String, String>>,
}

impl ConnectPayload {
  pub fn new<F1, F4, F5, F10>(client_identifier: F1, client_info: F4, password: F5, app_specific_info: F10) -> ConnectPayload where F1: Into<Option<String>>, F4: Into<Option<Box<ClientInfo>>>, F5: Into<Option<String>>, F10: Into<Option<BTreeMap<String, String>>> {
    ConnectPayload {
      client_identifier: client_identifier.into(),
      client_info: client_info.into(),
      password: password.into(),
      app_specific_info: app_specific_info.into(),
    }
  }
}

impl TSerializable for ConnectPayload {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConnectPayload> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_4: Option<Box<ClientInfo>> = None;
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_10: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        4 => {
          let val = Box::new(ClientInfo::read_from_in_protocol(i_prot)?);
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_0 = i_prot.read_string()?;
            let map_val_1 = i_prot.read_string()?;
            val.insert(map_key_0, map_val_1);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ConnectPayload {
      client_identifier: f_1,
      client_info: f_4,
      password: f_5,
      app_specific_info: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectPayload");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.client_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientIdentifier", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientInfo", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.app_specific_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("appSpecificInfo", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientInfo {
  pub user_id: Option<i64>,
  pub user_agent: Option<String>,
  pub client_capabilities: Option<i64>,
  pub endpoint_capabilities: Option<i64>,
  pub publish_format: Option<i32>,
  pub no_automatic_foreground: Option<bool>,
  pub make_user_available_in_foreground: Option<bool>,
  pub device_id: Option<String>,
  pub is_initially_foreground: Option<bool>,
  pub network_type: Option<i32>,
  pub network_subtype: Option<i32>,
  pub client_mqtt_session_id: Option<i64>,
  pub subscribe_topics: Option<Vec<i32>>,
  pub client_type: Option<String>,
  pub app_id: Option<i64>,
  pub device_secret: Option<String>,
  pub client_stack: Option<i8>,
}

impl ClientInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F14, F15, F16, F20, F21>(user_id: F1, user_agent: F2, client_capabilities: F3, endpoint_capabilities: F4, publish_format: F5, no_automatic_foreground: F6, make_user_available_in_foreground: F7, device_id: F8, is_initially_foreground: F9, network_type: F10, network_subtype: F11, client_mqtt_session_id: F12, subscribe_topics: F14, client_type: F15, app_id: F16, device_secret: F20, client_stack: F21) -> ClientInfo where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i32>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<String>>, F9: Into<Option<bool>>, F10: Into<Option<i32>>, F11: Into<Option<i32>>, F12: Into<Option<i64>>, F14: Into<Option<Vec<i32>>>, F15: Into<Option<String>>, F16: Into<Option<i64>>, F20: Into<Option<String>>, F21: Into<Option<i8>> {
    ClientInfo {
      user_id: user_id.into(),
      user_agent: user_agent.into(),
      client_capabilities: client_capabilities.into(),
      endpoint_capabilities: endpoint_capabilities.into(),
      publish_format: publish_format.into(),
      no_automatic_foreground: no_automatic_foreground.into(),
      make_user_available_in_foreground: make_user_available_in_foreground.into(),
      device_id: device_id.into(),
      is_initially_foreground: is_initially_foreground.into(),
      network_type: network_type.into(),
      network_subtype: network_subtype.into(),
      client_mqtt_session_id: client_mqtt_session_id.into(),
      subscribe_topics: subscribe_topics.into(),
      client_type: client_type.into(),
      app_id: app_id.into(),
      device_secret: device_secret.into(),
      client_stack: client_stack.into(),
    }
  }
}

impl TSerializable for ClientInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<bool> = Some(false);
    let mut f_10: Option<i32> = Some(0);
    let mut f_11: Option<i32> = Some(0);
    let mut f_12: Option<i64> = Some(0);
    let mut f_14: Option<Vec<i32>> = Some(Vec::new());
    let mut f_15: Option<String> = Some("".to_owned());
    let mut f_16: Option<i64> = Some(0);
    let mut f_20: Option<String> = Some("".to_owned());
    let mut f_21: Option<i8> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        14 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i32()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_i8()?;
          f_21 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientInfo {
      user_id: f_1,
      user_agent: f_2,
      client_capabilities: f_3,
      endpoint_capabilities: f_4,
      publish_format: f_5,
      no_automatic_foreground: f_6,
      make_user_available_in_foreground: f_7,
      device_id: f_8,
      is_initially_foreground: f_9,
      network_type: f_10,
      network_subtype: f_11,
      client_mqtt_session_id: f_12,
      subscribe_topics: f_14,
      client_type: f_15,
      app_id: f_16,
      device_secret: f_20,
      client_stack: f_21,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClientInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_agent {
      o_prot.write_field_begin(&TFieldIdentifier::new("userAgent", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.client_capabilities {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientCapabilities", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.endpoint_capabilities {
      o_prot.write_field_begin(&TFieldIdentifier::new("endpointCapabilities", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.publish_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("publishFormat", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_automatic_foreground {
      o_prot.write_field_begin(&TFieldIdentifier::new("noAutomaticForeground", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.make_user_available_in_foreground {
      o_prot.write_field_begin(&TFieldIdentifier::new("makeUserAvailableInForeground", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_initially_foreground {
      o_prot.write_field_begin(&TFieldIdentifier::new("isInitiallyForeground", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.network_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("networkType", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.network_subtype {
      o_prot.write_field_begin(&TFieldIdentifier::new("networkSubtype", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.client_mqtt_session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientMqttSessionId", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.subscribe_topics {
      o_prot.write_field_begin(&TFieldIdentifier::new("subscribeTopics", TType::List, 14))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientType", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.app_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.device_secret {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceSecret", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.client_stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientStack", TType::I08, 21))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

